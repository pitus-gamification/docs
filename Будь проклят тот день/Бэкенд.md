
## 1. Общая структура и требования

1. **Стек технологий**
    
    - Общение по HTTP(S), формат данных — JSON.
    - Аутентификация и авторизация через JWT или аналогичный механизм (сессионные куки).
    - Бэкенд должен работать с тремя ролями:
        - **User** (через Telegram Mini App)
        - **Moderator** (через приложение для сканирования QR)
        - **Admin** (для создания и управления мероприятиями)
2. **Основные роли**
    
    - **User** (студент, гость): просматривает мероприятия, регистрируется, получает QR, видит профиль, баллы и достижения.
    - **Moderator**: авторизуется в приложении модератора, сканирует QR-код, подтверждает или отклоняет доступ, что фиксирует посещение и начисляет баллы.
    - **Admin**: управляет мероприятиями (создание, редактирование, удаление) и, при необходимости, статистикой. Также администратор вручную выдаёт достижения.
3. **Основные сущности**
    
    1. **User (Пользователь)**
        
        - `id` (уникальный идентификатор — UUID или числовой ID)
        - `telegramId` (при необходимости)
        - `name`
        - `email`
        - `academicGroup`
        - `photoUrl` (ссылка на фото)
        - `points` (текущее количество баллов)
        - Связь с достижениями (через таблицу `UserAchievement` или аналог)
        - Дата создания/обновления
    2. **Event (Мероприятие)**
        
        - `id`
        - `title`
        - `description` (общее описание)
        - `bannerUrl` (ссылка на изображение/баннер мероприятия)
        - `startDateTime`
        - `endDateTime`
        - `location` (опционально)
        - `vkLink` (опционально)
        - `tgLink` (опционально)
        - `points` (количество баллов, которые начисляются за посещение)
        - **[Уточнение]** Каждое мероприятие имеет установленный промежуток времени (регистрации/подтверждения), в течение которого разрешено сканирование QR-кода.
        - Дата создания/обновления
    3. **EventScheduleItem** (расписание внутри мероприятия, если нужно отдельными блоками)
        
        - `id`
            
        - `eventId`
            
        - `startTime` / `endTime`
            
        - `title` (название блока, секции, выступления)
            
        - `speaker` (опционально)
            
        
        > Если не нужно детально хранить расписание, можно оставить его в `description`. Однако, учитывая уточнения, предполагается наличие отдельной сущности.
        
    4. **Registration (регистрация + посещение)**
        
        - `id`
        - `userId`
        - `eventId`
        - `qrCodeHash` – **[Уточнение]** Это единственное поле, кодируется в QR-код. В макетах не оговаривается иной формат QR, поэтому используется только `qrCodeHash`. Модератор получает всю информацию о регистрации с бэкенда.
        - `isApproved` (подтверждено ли участие)
        - `isRejected` (либо используется единое поле `status` с возможными значениями: `pending/approved/rejected`)
        - `approvedAt` (дата/время подтверждения, если `isApproved = true`)
        - Дата создания/обновления
    5. **Moderator (Модератор)**
        
        - `id`
        - `login` (уникальный)
        - `passwordHash` (хранить в безопасном виде)
        - Дата создания/обновления
    6. **Admin (Администратор)**
        
        - Может храниться в той же таблице, что и модераторы, с признаком `role = admin`, либо в отдельной.
    7. **Achievement (Достижения)**
        
        - `id`
            
        - `title` (название достижения)
            
        - `description` (условие получения, описание)
            
        - `iconUrl` (ссылка на иконку, если нужно)
            
        - Дата создания/обновления
            
        - **[Уточнение]** Логика автоматического присвоения достижений не планируется. Администратор вручную выдаёт достижения, поэтому бизнес-логика автоматической проверки отсутствует.
            
        - Связка «пользователь ↔ достижения» (например, `UserAchievement`) фиксирует, какие достижения у пользователя есть.
            

---

## 2. Эндпоинты и логика (для пользователей / Telegram Mini App)

### 2.1. Авторизация через Telegram

**Endpoint**: `POST /api/v1/auth/telegram`  
**Описание**:

- При первом входе валидируем данные (telegramId, hash, authDate и т.д.). Создаём запись `User` или обновляем, если пользователь уже существует.
- Возвращаем JWT-токен (или иной механизм) и данные пользователя.

**Пример запроса**:

```json
{
  "telegramId": "123456789",
  "username": "tg_username",
  "firstName": "Иван",
  "lastName": "Иванов",
  "photoUrl": "https://t.me/Ivan/avatar.jpg",
  "authDate": 1693912345,
  "hash": "abcdef1234567890..."
}
```

**Пример ответа**:

```json
{
  "status": "ok",
  "token": "<JWT>",
  "user": {
    "id": 42,
    "name": "Иван Иванов",
    "email": null,
    "academicGroup": null,
    "points": 0,
    "photoUrl": "https://t.me/Ivan/avatar.jpg"
  }
}
```

---

### 2.2. Профиль пользователя

#### 2.2.1. Обновление профиля

**Endpoint**: `PATCH /api/v1/user/profile`  
**Описание**:

- Используется ботом для передачи `email`, `academicGroup` и т.д.
- Требует авторизации (Bearer-токен).

**Пример запроса**:

```json
{
  "name": "Иван Иванов",
  "email": "ivan@example.com",
  "academicGroup": "Б05-004"
}
```

**Пример ответа**:

```json
{
  "status": "ok",
  "user": {
    "id": 42,
    "name": "Иван Иванов",
    "email": "ivan@example.com",
    "academicGroup": "Б05-004",
    "points": 0
  }
}
```

#### 2.2.2. Получение профиля

**Endpoint**: `GET /api/v1/user/profile`  
**Описание**:

- Возвращает данные пользователя, включая текущее количество баллов.

**Пример ответа**:

```json
{
  "status": "ok",
  "user": {
    "id": 42,
    "name": "Иван Иванов",
    "email": "ivan@example.com",
    "academicGroup": "Б05-004",
    "points": 100,
    "photoUrl": "https://t.me/Ivan/avatar.jpg"
  }
}
```

---

### 2.3. Мероприятия

#### 2.3.1. Список мероприятий

**Endpoint**: `GET /api/v1/events`  
**Описание**:

- Возвращает список мероприятий (актуальных/предстоящих, либо всех).
- Параметры: `status=upcoming|past` (по желанию), `limit`, `offset` и т.д.

**Пример ответа**:

```json
{
  "status": "ok",
  "events": [
    {
      "id": 101,
      "title": "День открытых дверей",
      "bannerUrl": "https://server.com/uploads/events/101.jpg",
      "startDateTime": "2025-10-01T10:00:00Z",
      "points": 10
    }
  ]
}
```

#### 2.3.2. Детальная информация о мероприятии

**Endpoint**: `GET /api/v1/events/{eventId}`  
**Описание**:

- Возвращает полную информацию: `title, description, bannerUrl, startDateTime, endDateTime, location, points, vkLink, tgLink`.
- Может содержать массив `schedule` (если используется сущность `EventScheduleItem`).
- Если пользователь авторизован, возвращается статус регистрации (`registered / not_registered`) и данные для формирования QR-кода.

**Пример ответа**:

```json
{
  "status": "ok",
  "event": {
    "id": 101,
    "title": "День открытых дверей",
    "description": "Подробное описание программы...",
    "bannerUrl": "https://server.com/uploads/events/101.jpg",
    "startDateTime": "2025-10-01T10:00:00Z",
    "endDateTime": "2025-10-01T16:00:00Z",
    "location": "Главный корпус, аудитория 101",
    "points": 10,
    "vkLink": "https://vk.com/examplepost",
    "tgLink": "https://t.me/examplechannel/123",
    "schedule": [
      {
        "id": 1001,
        "startTime": "2025-10-01T10:00:00Z",
        "endTime": "2025-10-01T10:30:00Z",
        "title": "Приветственное слово"
      }
    ],
    "userRegistration": {
      "status": "registered",
      "registrationId": 999,
      "qrCodeHash": "abc123def"
    }
  }
}
```

---

### 2.4. Регистрация и QR-код

#### 2.4.1. Регистрация на мероприятие

**Endpoint**: `POST /api/v1/events/{eventId}/register`  
**Описание**:

- Проверяем, что текущая дата/время находится в пределах установленного регистрационного окна (см. уточнение в разделе Event).
- Создаём запись в `Registration`, если её ещё нет.
- Если пользователь уже зарегистрирован, можно вернуть существующую запись или код `409 Conflict` (в зависимости от выбранной логики).
- Возвращаем `qrCodeHash`, `registrationId` и/или URL готового QR-кода.

**Пример ответа**:

```json
{
  "status": "ok",
  "registration": {
    "id": 999,
    "eventId": 101,
    "qrCodeHash": "abc123def"
  }
}
```

#### 2.4.2. Получение QR-кода (при необходимости)

**Endpoint**: `GET /api/v1/registration/{registrationId}/qrcode`  
**Описание**:

- Возвращает QR-код (в бинарном или base64 виде) либо ссылку на заранее сгенерированное изображение.

---

### 2.5. История посещений и баллы

#### 2.5.1. История посещений

**Endpoint**: `GET /api/v1/user/attendances`  
**Описание**:

- Возвращает список регистраций пользователя с указанием статуса (approved/rejected), баллов и другой информацией.

**Пример ответа**:

```json
{
  "status": "ok",
  "attendances": [
    {
      "eventId": 101,
      "title": "День открытых дверей",
      "startDateTime": "2025-10-01T10:00:00Z",
      "pointsEarned": 10,
      "isApproved": true,
      "isRejected": false
    },
    {
      "eventId": 102,
      "title": "Научная конференция",
      "startDateTime": "2025-10-10T09:00:00Z",
      "pointsEarned": 0,
      "isApproved": false,
      "isRejected": false
    }
  ]
}
```

#### 2.5.2. Достижения (Achievements)

- **Endpoint**: `GET /api/v1/achievements`  
    Возвращает список всех достижений (название, описание, иконка и т.д.).
- **Endpoint**: `GET /api/v1/user/achievements`  
    Возвращает достижения конкретного пользователя.

> **[Уточнение]** Логика автоматического присвоения достижений не реализуется. Выдача достижений осуществляется исключительно вручную администратором через эндпоинты управления (см. раздел 4).

---

## 3. Эндпоинты приложения модератора

### 3.1. Авторизация

**Endpoint**: `POST /api/v1/moderator/login`  
**Описание**:

- Принимает `login` и `password`.
- Возвращает токен или сессию для дальнейшего использования.

---

### 3.2. Сканирование QR-кода

#### 3.2.1. Передача `qrCodeHash` на сервер

**Endpoint**: `POST /api/v1/moderator/scan`  
**Описание**:

- Принимает `qrCodeHash` и ищет соответствующую запись в таблице `Registration`.
- **[Уточнение по ограничениям]** Повторное сканирование одного и того же QR-кода возможно, но:
    - Если регистрация уже была одобрена, повторное сканирование не приводит к повторному начислению баллов. В ответ возвращается сообщение о том, что QR-код уже использован (дубликат).
    - Если время мероприятия или регистрационного окна истекло, возвращается ошибка.
- Если запись найдена и условия соблюдены, возвращаются данные пользователя (id, name, photoUrl) и мероприятия (id, title, startDateTime).

**Пример запроса**:

```json
{
  "qrCodeHash": "abc123def"
}
```

**Пример ответа**:

```json
{
  "status": "ok",
  "user": {
    "id": 42,
    "name": "Иван Иванов",
    "photoUrl": "https://server.com/uploads/users/42.png"
  },
  "event": {
    "id": 101,
    "title": "День открытых дверей",
    "startDateTime": "2025-10-01T10:00:00Z"
  },
  "registration": {
    "id": 999,
    "isApproved": false,
    "isRejected": false
  }
}
```

---

### 3.3. Принятие решения (одобрить/отклонить)

#### 3.3.1. Одобрить

**Endpoint**: `POST /api/v1/moderator/registration/{registrationId}/approve`  
**Описание**:

- Устанавливается флаг `isApproved = true`, `approvedAt = now()`, и `isRejected = false`.
- **[Уточнение по баллам]** Баллы начисляются пользователю (прибавляется `event.points` к `User.points`) только при первом одобрении. Повторное одобрение не приводит к дополнительному начислению баллов.
- Если регистрация уже одобрена, повторный вызов возвращает статус дубликата без изменения баллов.

**Пример ответа**:

```json
{
  "status": "ok",
  "registration": {
    "id": 999,
    "isApproved": true,
    "isRejected": false,
    "approvedAt": "2025-10-01T10:15:00Z"
  }
}
```

#### 3.3.2. Отклонить

**Endpoint**: `POST /api/v1/moderator/registration/{registrationId}/reject`  
**Описание**:

- Устанавливается `isRejected = true` и `isApproved = false`.
- **[Уточнение по баллам]** Если регистрация была одобрена и баллы начислены, последующее отклонение не приводит к снятию уже начисленных баллов.
- При повторном отклонении статус остаётся неизменным, возвращается сообщение об отсутствии изменений.

---

## 4. Эндпоинты для администратора (Admin)

Администратор может создавать, редактировать и удалять мероприятия, а также управлять достижениями.

1. **Создание мероприятия**
    
    - **Endpoint**: `POST /api/v1/admin/events`
    - **Описание**: Принимает данные о мероприятии (`title`, `description`, `startDateTime`, `endDateTime`, `points`, `bannerUrl`, `location`, `vkLink`, `tgLink`, а также расписание).
    - **Ответ**: Возвращает созданный объект `Event`.
2. **Обновление мероприятия**
    
    - **Endpoint**: `PATCH /api/v1/admin/events/{eventId}`
    - **Описание**: Позволяет обновлять поля мероприятия, включая изменение `schedule` (при необходимости отдельными вызовами).
    - **Ответ**: Возвращает обновлённый объект `Event`.
3. **Удаление мероприятия**
    
    - **Endpoint**: `DELETE /api/v1/admin/events/{eventId}`
    - **Описание**: Удаляет мероприятие или помечает его как «отменённое».
4. **CRUD для расписания** (если необходимо детальное управление `EventScheduleItem`):
    
    - **Endpoint**: `POST /api/v1/admin/events/{id}/schedule`
    - **Endpoint**: `PATCH /api/v1/admin/events/{id}/schedule/{scheduleItemId}`
    - **Endpoint**: `DELETE /api/v1/admin/events/{id}/schedule/{scheduleItemId}`
5. **CRUD для достижений (Achievements)**
    
    - **Endpoint**: `POST /api/v1/admin/achievements`
        
    - **Endpoint**: `PATCH /api/v1/admin/achievements/{id}`
        
    - **Endpoint**: `DELETE /api/v1/admin/achievements/{id}`
        
    
    > **[Уточнение]** Достижения выдаются администратором вручную, без автоматической логики присвоения. Эндпоинты позволяют управлять списком достижений.
    

> **Важно**: Все эндпоинты администратора (и некоторые модераторские) требуют проверки прав (например, наличие `role = admin` или соответствующей роли).

---

## 5. Дополнительные проверки и бизнес-логика

1. **Проверка «просроченности»**
    
    - При вызове `POST /events/{eventId}/register` проверяется, что текущая дата/время находится в пределах регистрационного окна (до окончания мероприятия).
    - При сканировании QR-кода также проверяется, что мероприятие актуально и сканирование производится в установленное время.
2. **Повторные действия (approve/reject)**
    
    - Если регистрация уже имеет статус `isApproved = true`, повторное одобрение не приводит к дополнительному начислению баллов.
    - Если регистрация уже имеет статус `isRejected = true`, повторное отклонение не изменяет состояние.
3. **Логика начисления баллов**
    
    - Баллы начисляются один раз за каждое мероприятие. После первого одобрения регистрационной записи, повторное сканирование или смена статуса не приводит к повторному начислению.
    - Если модератор сначала одобрил регистрацию, а затем выполнил отклонение, баллы не снимаются.
4. **Безопасность**
    
    - Все пароли (модераторов, админов) хранятся в хэшированном виде (bcrypt, Argon2, PBKDF2 и т.д.).
    - Конечные точки `/auth/telegram` и `/moderator/login` защищены от brute force-атак (ограничение количества попыток).
    - Все данные (включая JWT-токены) передаются исключительно по HTTPS.
5. **Отчётность / аналитика**
    
    - Администратору может понадобиться список зарегистрировавшихся пользователей. Для этого можно использовать эндпоинт `GET /api/v1/admin/events/{eventId}/registrations` с соответствующей авторизацией.

---

## 6. Ошибки и коды ответов

- **200 OK** — стандартный успешный ответ (чтение, обновление).
- **201 Created** — при создании (например, нового мероприятия или регистрации).
- **400 Bad Request** — неверные входные данные или попытка регистрации/сканирования после окончания мероприятия.
- **401 Unauthorized** — отсутствие или недействительность токена.
- **403 Forbidden** — недостаточно прав для выполнения запроса (например, вызов административных эндпоинтов обычным пользователем).
- **404 Not Found** — сущность (пользователь, мероприятие, регистрация) не найдена.
- **409 Conflict** — конфликт, например, повторная регистрация на одно и то же мероприятие или повторное сканирование QR-кода.
- **500 Internal Server Error** — внутренняя ошибка сервера.

---

## 7. Итоговая схема работы

1. **Пользователь**
    
    - Заходит через Telegram → передаёт данные на `/auth/telegram` → получает токен.
    - Просматривает список мероприятий (`GET /events`, `GET /events/{id}`).
    - Регистрируется на мероприятие через `/events/{id}/register` (с проверкой, что текущее время входит в регистрационное окно), получает `qrCodeHash` для QR-кода.
    - В любое время может просматривать профиль (`GET /user/profile`), историю посещений (`GET /user/attendances`) и достижения (`GET /user/achievements`).
2. **Модератор**
    
    - Авторизуется через `/moderator/login`.
    - Сканирует QR-код через `/moderator/scan`. Если регистрация уже одобрена, повторное сканирование возвращает сообщение о дубликате без повторного начисления баллов.
    - При подтверждении регистрации вызывает `/moderator/registration/{registrationId}/approve` (баллы начисляются один раз) или `/reject` (без обратного снятия баллов).
3. **Администратор**
    
    - Авторизуется с правами администратора.
    - Создаёт, редактирует, удаляет мероприятия через эндпоинты `/admin/events` (и опционально управляет расписанием через `/admin/events/{id}/schedule`).
    - Управляет достижениями вручную через эндпоинты `/admin/achievements`.
4. **Начисление баллов и достижения**
    
    - При первом одобрении регистрации (через `/approve`) пользователю начисляются баллы (`user.points += event.points`).
    - Баллы за одно и то же событие начисляются только один раз.
    - Логика автоматической выдачи достижений отсутствует. Достижения присваиваются исключительно администратором через соответствующие эндпоинты.

